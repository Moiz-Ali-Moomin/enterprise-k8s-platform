# Enterprise-grade Ingress Controller Configuration

controller:
  # 1. High Availability & Autoscaling
  replicaCount: 3
  
  # Correct PDB Configuration
  podDisruptionBudget:
    enabled: true
    minAvailable: 2

  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    # Note: Memory scaling requires Metrics Server. 
    # Validated in staging before enabling in production.
    targetMemoryUtilizationPercentage: 75

  # 2. Resource Management
  resources:
    requests:
      cpu: 500m
      memory: 512Mi
    limits:
      cpu: 1000m
      memory: 1Gi

  # 3. Security Hardening
  containerSecurityContext:
    allowPrivilegeEscalation: false
    runAsNonRoot: true
    runAsUser: 101 # nginx user
    capabilities:
      drop:
        - ALL
      add:
        - NET_BIND_SERVICE
  
  # 4. AWS NLB Specific Configuration
  service:
    enabled: true
    externalTrafficPolicy: Local # Preserves Client IP
    # Modern EKS LoadBalancer approach
    loadBalancerClass: service.k8s.aws/nlb
    annotations:
      # Legacy annotations kept for compatibility, can be removed if using loadBalancerClass exclusively
      service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
      service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"
      service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
      # WAF & Shield Integration
      service.beta.kubernetes.io/aws-load-balancer-type: "external"
      service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "ip"
  
  # 5. NGINX Tuning & Logging
  config:
    # Security: Access Log Format with Request ID and Latency
    log-format-upstream: '$remote_addr - $request_id [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" $request_length $request_time [$proxy_upstream_name] [$proxy_alternative_upstream_name] $upstream_addr $upstream_response_length $upstream_response_time $upstream_status $req_id'
    
    use-forwarded-headers: "true"
    compute-full-forwarded-for: "true"
    keep-alive: "75"
    client-body-timeout: "60"
    client-max-body-size: "10m"
    worker-processes: "auto"
    enable-real-ip: "true"
  
  # 6. Observability
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true
      additionalLabels:
        release: "prometheus"
      scrapeInterval: 10s

  # 7. Graceful Termination
  lifecycle:
    preStop:
      exec:
        command: ["/bin/sh", "-c", "sleep 5; /usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf -s quit; while pgrep -x nginx; do sleep 1; done"]

  # 8. Scheduling
  topologySpreadConstraints:
    - maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: DoNotSchedule
      labelSelector:
        matchLabels:
          app.kubernetes.io/name: ingress-nginx
          app.kubernetes.io/component: controller
  
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app.kubernetes.io/name
              operator: In
              values:
              - ingress-nginx
            - key: app.kubernetes.io/component
              operator: In
              values:
              - controller
          topologyKey: kubernetes.io/hostname

# 9. Default Backend
defaultBackend:
  enabled: true
  replicaCount: 2
  resources:
    requests:
      cpu: 10m
      memory: 20Mi
    limits:
      cpu: 20m
      memory: 50Mi
